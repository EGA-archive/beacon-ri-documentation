Documentation Beacon 2 PI API Configuration
Beacon 2 Production Implementation API
Configuration
Beacon2 PI API has two folders where a user can configure their beacons: conf for general configuration of the beacon and source for configuring the model of the beacon: e.g. entry types and the databases related to each entry type.

Generic configuration
The beacon needs some configuration in order to show the correct mappings or information. In order to do that, the next variables inside conf.py can be modified for that purpose, being uri a critical one for showing the correct domain in the mappings of your beacon. The uri_subpath will be added behind this uri variable, in case there is an extension of the domain for your beacon.

beacon_id = 'org.ega-archive.beacon-ri-demo' # ID of the Beacon
beacon_name = 'Beacon Reference Implementation demo' # Name of the Beacon service
api_version = 'v2.0.0' # Version of the Beacon implementation
uri = 'http://localhost:5050'
uri_subpath = '/api'
complete_url = uri + uri_subpath
environment = 'test'
description = r"This Beacon is based on synthetic data hosted at the <a href='https://ega-archive.org/datasets/EGAD00001003338'>EGA</a>. The dataset contains 2504 samples including genetic data based on 1K Genomes data, and 76 individual attributes and phenotypic data derived from UKBiobank."
version = api_version_yaml['api_version']
welcome_url = 'https://beacon.ega-archive.org/'
alternative_url = 'https://beacon.ega-archive.org/api'
create_datetime = '2021-11-29T12:00:00.000000'
update_datetime = ''
default_beacon_granularity = "record" # boolean, count or record
security_levels = ['PUBLIC', 'REGISTERED', 'CONTROLLED']
documentation_url = 'https://b2ri-documentation-demo.ega-archive.org/'
cors_urls = ["http://localhost:3003", "http://localhost:3000"]

# Service Info
ga4gh_service_type_group = 'org.ga4gh'
ga4gh_service_type_artifact = 'beacon'
ga4gh_service_type_version = '1.0'

# Organization info
org_id = 'EGA' # Id of the organization
org_name = 'European Genome-Phenome Archive (EGA)' # Full name
org_description = 'The European Genome-phenome Archive (EGA) is a service for permanent archiving and sharing of all types of personally identifiable genetic and phenotypic data resulting from biomedical research projects.'
org_adress = 'C/ Dr. Aiguader, 88, PRBB Building 08003 Barcelona, Spain'
org_welcome_url = 'https://ega-archive.org/'
org_contact_url = 'mailto:beacon.ega@crg.eu'
org_logo_url = 'https://legacy.ega-archive.org/images/logo.png'
org_info = ''

Budget configuration
If you wish to put a limit on how many queries can a user or a certain IP make to your beacon, that is now possible. In order to do that, edit the the variables under Query budget inside conf.py.

# Query Budget
query_budget_per_user = False
query_budget_per_ip = False
query_budget_amount = 3
query_budget_time_in_seconds = 20
query_budget_database = 'mongo'
query_budget_db_name = 'beacon'
query_budget_table = 'budget'

The variables query_budget_per_user and query_budget_per_ip are boolean, and if True, they will restrict the queries per user and ip. These depend onquery_budget_amount which will tell the amount allowed per user/ip and query_budge_time_in_seconds which will be the period of time that this amount of queries attempt will last. Bear in mind that activating query budget per user means that if a user is not authenticated, the query will fail unless the query budget per ip is also activated. Both ip and user budgets can be activated at the same time, having preference per user but if unauthenticated, ip queries will also be valid.

Query rounding
The last thing you can configure inside conf.py is query rounding, editing the variables under that name.

# Query Rounding
imprecise_count=0 # If imprecise_count is 0, no modification of the count will be applied. If it's different than 0, count will always be this number when count is smaller than this number.
round_to_tens=False # If true, the rounding will be done to the immediate superior tenth if the imprecise_count is 0
round_to_hundreds=False # If true, the rounding will be done to the immediate superior hundredth if the imprecise_count is 0 and the round_to_tens is false

The variable imprecise_count will override all the others and will tell beacon to round the counts to a number equal or greater than the one assigned to this variable. After that, the round_to_tens is the variable that will have priority if true, and will round a count to the immediate superior tenth. The last oneround_to_hundreds will do the same as the one before but rounding to the immedate superior hundredth.

Entry types configuration
Beacon v2 PI API lets you change the configuration of each of the entry types. For doing that, you have to edit the entry types configuration for each entry type (e.g. analysis.py) and there you will find the next variables:

endpoint_name="analyses"
open_api_endpoints_definition='https://raw.githubusercontent.com/ga4gh-beacon/beacon-v2/main/models/json/beacon-v2-default-model/analyses/endpoints.json'
database='mongo' # The name must match the folder's name in connection that belongs to the desired database.

# Granularity accepted: boolean, count or record
granularity='record'

# Entry type configuration
id='analysis'
name='Bioinformatics analysis'
ontology_id='edam:operation_2945'
ontology_name='Analysis'
specification='Beacon v2.0.0'
description='Apply analytical methods to existing data of a specific type.'
defaultSchema_id='beacon-analysis-v2.0.0'
defaultSchema_name='Default schema for a bioinformatics analysis'
defaultSchema_reference_to_schema_definition='https://raw.githubusercontent.com/ga4gh-beacon/beacon-v2/main/models/json/beacon-v2-default-model/analyses/defaultSchema.json'
defaultSchema_schema_version='v2.0.0'
aditionally_supported_schemas=[]
allow_queries_without_filters=True

# Map configuration
singleEntryUrl=True # True if your beacon enables endpoint analyses/{id}
biosample_lookup=True # True if your beacon enables endpoint analyses/{id}/biosamples
cohort_lookup=True # True if your beacon enables endpoint analyses/{id}/cohorts
dataset_lookup=True # True if your beacon enables endpoint analyses/{id}/datasets
genomicVariant_lookup=True # True if your beacon enables endpoint analyses/{id}/g_variants
individual_lookup=True # True if your beacon enables endpoint analyses/{id}/individuals
run_lookup=True # True if your beacon enables endpoint analyses/{id}/runs

The most importants are the variable endpoint_name, which will change the name of the endpoint that will show the response for analysis type of records, the granularity, which will change the maximum granularity allowed for this particular entry type, the allow_queries_without_filters, which will allow queries without filters if True to that particular endpoint. Also, defaultSchema_id says which is the version of the schema of the records that are stored in this entry type and when receiving a requestedSchema different than this id, the beacon will respond with a bad request, as other schemas are not supported. The variables that are below Map configuration which will activate or deactivate the different endpoints related to this entry type. See explanation next to each of the variables to know more.

To show correctly your beaconâ€™s information you will need to edit both conf.py files from beacon and deploy folders.
To do so, edit the following variables:

beacon_id = 'org.ega-archive.beacon-ri-demo'

beacon_name = 'Beacon Reference Implementation demo'

api_version = 'v2.0.0'

uri = 'https://beacon-apis-demo.ega-archive.org/api/'

org_id = 'EGA'

org_name = 'European Genome-Phenome Archive (EGA)'

org_description = 'The European Genome-phenome Archive (EGA) is a service for permanent archiving and sharing of all types of personally identifiable genetic and phenotypic data resulting from biomedical research projects.'

org_adress = 'C/ Dr. Aiguader, 88
PRBB Building
08003 Barcelona, Spain'

org_welcome_url = 'https://ega-archive.org/'

org_contact_url = 'mailto:beacon.ega@crg.eu'

org_logo_url = 'https://legacy.ega-archive.org/images/logo.png'

org_info = ''

description = "This Beacon is based on synthetic data hosted at the EGA. The dataset contains 2504 samples including genetic data based on 1K Genomes data, and 76 individual attributes and phenotypic data derived from UKBiobank."
version = 'v2.0'

welcome_url = 'https://beacon.ega-archive.org/'

alternative_url = 'https://beacon-apis-demo.ega-archive.org/api/'

create_datetime = '2021-11-29T12:00:00.000000'

update_datetime = ''

Note symbol
Note that this is the info that will be shown in the /info endpoint for your beacon.

Managing dataset permissions
There are 3 possible levels of beacon security for a dataset: public, registered and controlled.

A public dataset is a dataset that will be returned in a beacon query without an authentication token. 
A registered dataset is a dataset that will be shown after a user sends a valid token (in other words, is logged in).
A controlled dataset is a dataset that needs a user to send a valid token for authentication and the user needs to be allowed to query that dataset.

Edit the .yml files inside permissions/datasets
In order to assign the security level for a dataset in your beacon, please go to datasets_permissions.yml and add your dataset you wish to assign the permissions for it.
The 3 possible options to allow for the dataset are public,registered or controlled, which needs to be in the first item under the dataset name.
Public means that authentication is not required
Registered means authentication required
Controlled means authentication required and with specific permissions for the authenticated user.
After that, depending on the security level you assigned to the dataset, you can set a default_entry_types_granularity, which will set which is the maximum granularity allowed for this dataset, except for the entry_types_exceptions, that can assign a particular granularity for a particular entry type. Beware that the entry type needs to match the entry type id you set for each of the entry type files in their respective conf file: id of analysis, individual, etc.

CINECA_synthetic_cohort_EUROPE_UK1:
  public:
    default_entry_types_granularity: record
    entry_types_exceptions:
      - cohort: boolean

random_dataset:
  registered:
    default_entry_types_granularity: count
    entry_types_exceptions:
      - individual: boolean

If you have assigned a controlled security level then you can assign a particular granularity per user and per entry type per user. You can do that by creating a user-list array with items that belong to each user and that need to have the following structure:

AV_Dataset:
  controlled:
    default_entry_types_granularity: record
    entry_types_exceptions:
      - individual: boolean
    user-list:
      - user_e-mail: jane.smith@beacon.ga4gh
        default_entry_types_granularity: count
        entry_types_exceptions:
          - individual: record

Supplying AAI credentials for your Identity Provider (IDP)
For making any IDP (based on OpenID and Oauthv2) work with beacon, you will need to add the client ID and client secret for each IDP in a new file you have to create inside auth/idp_providers folder (for each IDP). This file must have a name with an .env extension (e.g. something.env) and needs to have the following variables:

CLIENT_ID=beacon 
CLIENT_SECRET='b26ca0f9-1137-4bee-b453-ee51eefbe7ba' 
USER_INFO='http://idp:8080/auth/realms/Beacon/protocol/openid-connect/userinfo' 
INTROSPECTION='http://idp:8080/auth/realms/Beacon/protocol/openid-connect/token/introspect' 
ISSUER='http://localhost:8080/auth/realms/Beacon' 
JWKS_URL='http://idp:8080/auth/realms/Beacon/protocol/openid-connect/certs'

After that, make sure you build your beacon container again:

docker-compose up -d --build beaconprod

Handling CORS
To avoid CORS using beacon and the frontend or a third-party authorization site like Keycloak, you will have to include all these URLs inside variable cors_urls in beacon/conf/conf.py file.
Example usage:

cors_urls = ["http://localhost:3000","https://cancer-beacon-demo.ega-archive.org", "https://beacon-network-demo2.ega-archive.org", "https://beacon.ega-archive.org"]

Setting the default granularity
Beacon PI can only limit the granularity for all the beacon at the moment. If you want to limit the granularity for all users across all datasets, you can point it in becon/conf/conf.py, by editing the next variables:

max_beacon_granularity = "record"

Adding beacon handovers
A handover can be added to the general beacon response or to the response per dataset.
In any of the cases, you have to modify the beacon/utils/handovers.py file and you can write your handover there following the Beacon v2 spec response for handovers, e.g.

handover_1= {
  "note": "Description of the handover",
  "url": "Link for the handover",
  "handoverType": {
    "id": "NCIT:C189151",
    "label": "Study Data Repository"   } }

General response
After doing that if you want to just show the handover in general (not per dataset) you will need to include it in the list_of_handovers array:

list_of_handovers=[handover_1]

Handover per dataset
If you want to add the handover per dataset, then you will need to create first a dictionary per dataset with the handover and the dataset id, like this:

dataset1_handover = { "dataset": dataset1_id, "handover": handover_1 }

And then you will need to add it in the next array:

list_of_handovers_per_dataset=[dataset1_handover]

Configuring your entry types
If you go to the source folder inside beacon folder, you will find a file called manage.py that you will need to edit in order to tell the API what is implemented in your beacon for each entry type and in what database you have the data related to each entry_type.

In order to do this, you will just need to put a True or False response to what granularity you have implemented per each entryType. See the next example:

g_variants={ 'granularity': {
                  'boolean': True,
                  'count': True,
                  'record': True },
          'singleEntryUrl': True,
          'endpoints': {'analysis': True, 'biosample': True, 'individual': True, 'run': True },
          'testMode': True,
          'database': 'mongo' }

If none of the granularities are True, then beacon will not look at the other variables (as entryType will be programmed as not implemented). If some of the granularities are True, then, singleEntryUrl will tell if a beacon has the id queries implemented for this entryType and for each endpoint inside endpoints, which cross query with this entryType and the id parameter is implemented as well. The testMode is to point if the entryType can be queried using testMode and the database field will tell the users which database has the data for that particular entryType.

Note symbol
Bear in mind that the name of the database variable needs to be the exact same name that the name for the folder it corresponds to in beacon/connections.

Setting the logs
In this production instance of beacon, you can set the level of the logs you want to output and where do you want to see the output in.

All the outputs will be streamed but if you define a path for a log file (file with extension .log) you will be able to have all the history of logs for your beacon saved in this file.

For setting the level of the logs, specify one amongst NOTSET, DEBUG, ERROR, INFO in the variable level (after logging.):

level=logging.NOTSET

For setting the path to the file, define it in the variable log_file:

log_file=None

Note symbol
To save the logs in a file out of docker, you will need to create a volume for the file. There is a default log file volume defined in the docker-compose, which is -./beacon/logs/logs.log:/beacon/logs/logs.log, hence no need to create any other volume if you use this same file for logs.


TLS configuration
To enable TLS for the Becaon API set beacon_server_crt and beacon_server_key to the full paht of the server certificate and server key in beacon/conf/conf.py file.

TLS secured MongoDB
Edit the file beacon/connections/mongo/conf.py  and set database_certificate to the full path to the client certificate. If a private CA is used also set the database_cafile to the full path to the CA certificate.
The MongoDB client certificate should be in the combined PEM format client.key + "\n" + client.crt

Test Mode
For verifying your beacon, there are datasets that you can reproduce from the real data ones, that can serve as test but with fake data. When verifying your beacon, the verifiers will test those datasets. Also, for unit testing, there is a test dataset we use. For declaring your dataset a test dataset, you have to edit the datasets_conf.yml file and add an isTest: true parameter under the dataset desired, like this example:

CINECA_synthetic_cohort_EUROPE_UK1:
  isTest: false
test:
  isSynthetic: true
  isTest: true

